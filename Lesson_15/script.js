// ! асинхронность в JS

// мы писали до этого синхронный код
// он срабатывает последовательно по опрядку сверху вниз
//  но в js мі имеем возможность работать с кодами, выполнение которого будет откладываться 
// ниже рассмотрим примеры ассинхронности в js


// * setTimeout()

// откладывает выполнение кода на заданное время
//  принимает два аргумент:
// 1. функцию с кодомб которая сработает после истечении заданного времени
// 2. время в милисекундах

//console.log('начало!');

setTimeout(() => {
   // console.log('Прошло 2 секунды!')
}, 5000)

//console.log('конец!');

// ! любой асинхронный код сработает позже синхронного кода
// даже если в setTimeout указать 0 секунд

// ? setInterval()

// задает повторное выполнение кода
// первым аргументов принимает функцию с описанием действия 
//  вторым аргументом значение времени через которое действие сработает в милисекундах
//  интервал будет повторяется до тех пор, пока мы его не остановим
// для того, чтобы его остановить в будущем мы кладем ссылку на него в переменную

const interval = setInterval(() => {
    //console.log('Tick!');
},2000)

// чтобы остановить интервал мы принимаем к нему метод clearInterval()
setTimeout(()=> {
    clearInterval(interval)
}, 7000)

// это действие синхронное, поэтому оно сработает раньше чем setTimeout и setInterval
//console.log('P.S.');

// ! async requests & promises
// API - Application Programming Interface
// способ общаться разным програмамам друг с другом
//  набор правил позволяющий одним программам понимать другие програмы,
// обшаться друг с другом и обмениваться информацией

//  часто когда мы работаем с API мы хотим сделать запрос за данными чтобы обработать их в своем коде и отобразить на своей странице

//  если мы хотим получить удаленные данные по запросу мы используем ключевое слово fetch() (в переводе 'принеси')

// в ответ на запрос мне приходят данные в виде обьекта Promise
//  Promise - это особый вид данных в JS который нуждается в обработке. У него есть три состояния:
// 1. <Pending> - ожидание данных
// 2. <Fulfilled> -  данные успешно пришли
// 3. <Rejected> -  данные пришли с ошибкой

// ? запрос не получится обработать синхронно
// const data = fetch('https://dog.ceo/api/breeds/image/random/3'), не можем гарантировать когда прийдет код, поэтому нужно писать то что ниже

// ? чтобы обработать асинхронный запрос возвращающий обьект Promise мы используем метод then()(внурть себя принимает данные)
// then(res) получаем сырые данные

// ! короткий fetch запрос только про успех

// fetch("https://dog.ceo/api/breed")
//   .then((res) => res.json())
//   .then((data) => {
//     const img = document.createElement("img");
//     img.src = data.message;
//     document.body.append(img);
//   })

// ! длинный fetch запрос обрабатывающий ошибку

// запрос за данными возвращающий promise который мы обрабатываем через then()

fetch("https://dog.ceo/api/breeds/image/random")
  .then((res) => {
    // если поле ok - в положении false мы переходим к блоку catch отрабатывающего ошибку
    if (!res.ok) {
      throw new Error(`Ошибка: ${res.status}`);
    }
    return res.json()
  })
  // если все хорошо обрабатываем данные
  .then((data) => {
    const img = document.createElement("img");
    img.src = data.message;
    document.body.append(img);
  })
  // если ошибка показываем ее в консоли
  .catch((error) => {
    console.log(error);
  });






